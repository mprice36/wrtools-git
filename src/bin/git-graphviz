#!/usr/bin/env bash

#HELP:COMMAND_NAME: Build and display a git repository graph using GraphViz
#HELP:Usage: COMMAND_NAME [options]* -- rev-list ...
#HELP:Options:
#HELP:  --help | -h: print this help
#HELP:  --verbose | -v: print debugging and status output
#HELP:  --keep-temps | -k: Don't delete temporary files

set -o nounset -o errexit

root_dir=$(dirname "$0")/..
. "$root_dir"/share/wrtools-core/opt_help.bash
. "$root_dir"/share/wrtools-core/opt_verbose.bash
. "$root_dir"/share/wrtools-core/fail.bash
. "$root_dir"/share/wrtools-core/temp.bash

#HELP:  --url-at-remote=$remote-name | -u $remote-name: point commits to URLs based on
#HELP:                                                  a remote repo
unset url_at_remote
opt_url_at_remote () {
    (( $# == 1 ))|| fail_assert "$FUNCNAME expects 1 arg, a remote name"
    [[ -z ${url_at_remote+is-set} ]] || fail "$Option --url-at-remote can only be used once"
    url_at_remote=$1
}

#HELP:  --all | -a: show all commits & refs in the repository
unset all
opt_all () {
    (( $# == 0 )) || fail_assert "$FUNCNAME expects 0 args (got $#)"
    all=true
}

#HELP:  --decorate | -d: Decorate logs: show branches, tags, and references
unset decorate
opt_decorate () {
    (( $# == 0 )) || fail_assert "$FUNCNAME expects 0 args (got $#)"
    decorate=true
}

#HELP:  --open | -o: open the HTML result file
unset open
opt_open () {
    (( $# == 0 ))|| fail_assert "$FUNCNAME expects 0 args (got $#)"
    open=true
}

#HELP:  --date=$date-flag: set date format using git log --date option
#HELP:      values: relative, local, default, iso, iso-strict, rfc, short, raw
unset date
opt_date () {
    (( $# == 1 )) || fail_assert "$FUNCNAME expects 1 args (got $#)"
    case $1 in
        relative | local | default | iso | iso-strict | rfc | short | raw ) date=$1;;
        * ) fail "Unknown value for --date ($1)";;
    esac
}

OPTIND=1
while getopts :adhkou:v-: OPTION
do
    case "$OPTION" in
        a ) opt_all;;
        d ) opt_decorate;;
        h ) opt_help;;
        k ) opt_keep_temps;;
        o ) opt_open;;
        u ) opt_url_at_remote "$OPTARG";;
        v ) opt_verbose;;
        - )
            case "$OPTARG" in
                all ) opt_all;;
                decorate ) opt_decorate;;
                help ) opt_help;;
                keep-temps ) opt_keep_temps;;
                open ) opt_open;;
                verbose ) opt_verbose;;
                all=* | help=* | keep-temps=* | verbose=* | open=* ) 
                    fail "No argument expected for long option \"${OPTARG%%=*}\"";;

                date=* ) opt_date "${OPTARG#*=}";;
                url-at-remote=* ) opt_url_at_remote "${OPTARG#*=}";;
                url-at-remote | date )
                    fail "Missing required argument for long option \"$OPTARG\"";;
                
                * ) fail "Unexpected long option \"$OPTARG\"";;
            esac;;
        '?' ) fail "Unknown short option \"$OPTARG\"";;
        : ) fail "Short option \"$OPTARG\" missing argument";;
        * ) fail "bad state OPTARG=\"$OPTARG\"";;
    esac
done
shift $((OPTIND-1))

# $@ is git args

if [[ true = ${all-false} ]]
then set -- --full-history --all
     decorate=true
fi

git_log=(git log)
if [[ is-set = ${date+is-set} ]]
then git_log+=( --date="$date" )
fi

temp_make_dir git_graphviz

url_format="format:%H"
if [[ -n ${url_at_remote+is-set} ]]
then git remote show "$url_at_remote" > "$git_graphviz"/remote_show.txt || fail "Remote $url_at_remote not found"
     sed -e 's/^  Fetch URL: \(.*\)$/\1/p;d' < "$git_graphviz"/remote_show.txt > "$git_graphviz"/remote_url.txt
     remote_url=$(cat "$git_graphviz"/remote_url.txt)
     if [[ $remote_url == https://github.com/* ]]
     then printf -v url_format "%s/commit/%%H" "${remote_url%.git}"
     else fail "I don't know how to render remote $remote_url"
     fi
fi

omit_blank_lines () {
    egrep -v '^$' || true
}

# commit objects with parent1 and parent2
"${git_log[@]}" --format="commit %h parents %p" "$@" > "$git_graphviz"/commits-with-parents.txt
# commits with summary description
"${git_log[@]}" --format="commit %h summary %cN <%cE> %cd %s" "$@" > "$git_graphviz"/commits-with-summaries.txt

# sorting by commit, parent1, and parent2
sort -k 2b,2 "$git_graphviz"/commits-with-parents.txt > "$git_graphviz"/commits-with-parents.by-commit.txt
sort -k 4b,4 "$git_graphviz"/commits-with-parents.txt > "$git_graphviz"/commits-with-parents.by-parent-1.txt
sort -k 5b,5 "$git_graphviz"/commits-with-parents.txt > "$git_graphviz"/commits-with-parents.by-parent-2.txt
# get parent 1 and 2 where the parent is also in the list of commits
join -1 4 -2 2 -o 1.1,1.2,1.3,1.4 "$git_graphviz"/commits-with-parents.by-parent-1.txt "$git_graphviz"/commits-with-parents.by-commit.txt > "$git_graphviz"/parent-1-to-commit.txt
join -1 5 -2 2 -o 1.1,1.2,1.3,1.5 "$git_graphviz"/commits-with-parents.by-parent-2.txt "$git_graphviz"/commits-with-parents.by-commit.txt > "$git_graphviz"/parent-2-to-commit.txt

if [[ true = ${decorate-false} ]]
then
  # decoration-style refs
  # "${git_log[@]}" --format="object %h refs %D" "$@" > "$git_graphviz"/refs.txt
  # tags, each tag object with name and what it references
  git for-each-ref --format="%(if:equals=tag)%(objecttype)%(then)tag %(objectname:short) name %(refname:short) references %(*objectname:short)%(end)" refs/tags | omit_blank_lines > "$git_graphviz"/tags.txt
  git for-each-ref --format="%(if:equals=commit)%(objecttype)%(then)name %(refname:short) references %(objectname:short)%(end)" refs/tags | omit_blank_lines > "$git_graphviz"/lightweight-tags.txt
  git for-each-ref --format="%(if:equals=commit)%(objecttype)%(then)name %(refname:short) references %(objectname:short)%(end)" refs/heads refs/remotes | omit_blank_lines > "$git_graphviz"/references.txt
  git rev-parse --abbrev-ref HEAD > "$git_graphviz"/head.txt

  #############################################################################
  # pick references (branches & remotes)
  # sort references by referenced commit
  sort -k 4b,4 "$git_graphviz"/references.txt > "$git_graphviz"/references.by-referenced-commit.txt
  # join references to referenced commits
  join -1 4 -2 2 -o 1.1,1.2,1.3,1.4 "$git_graphviz"/references.by-referenced-commit.txt "$git_graphviz"/commits-with-parents.by-commit.txt > "$git_graphviz"/reference-to-commit.txt

  #############################################################################
  # pick tags
  sort -k 6b,6 "$git_graphviz"/tags.txt > "$git_graphviz"/tags.by-referenced-commit.txt
  # join tags to referenced commits
  join -1 6 -2 2 -o 1.1,1.2,1.3,1.4,1.5,1.6 "$git_graphviz"/tags.by-referenced-commit.txt "$git_graphviz"/commits-with-parents.by-commit.txt > "$git_graphviz"/tag-to-commit.txt

  #############################################################################
  # pick lightweight tags
  sort -k 4b,4 "$git_graphviz"/lightweight-tags.txt > "$git_graphviz"/lightweight-tags.by-referenced-commit.txt
  # join tags to referenced commits
  join -1 4 -2 2 -o 1.1,1.2,1.3,1.4 "$git_graphviz"/lightweight-tags.by-referenced-commit.txt "$git_graphviz"/commits-with-parents.by-commit.txt > "$git_graphviz"/lightweight-tag-to-commit.txt

  #############################################################################
  # pick HEAD
  sort -k 2b,2 "$git_graphviz"/reference-to-commit.txt > "$git_graphviz"/reference-to-commit.by-name.txt
  # join tags to referenced commits
  join -1 1 -2 2 -o 2.1,2.2 "$git_graphviz"/head.txt "$git_graphviz"/reference-to-commit.by-name.txt > "$git_graphviz"/head-to-reference.txt

fi

{
    cat <<EOF
digraph git_graph {
    edge [fontname = "Helvetica", fontsize = 10];
    node [fontname = "Helvetica", fontsize = 10, width = 0, height = 0, shape=box, style=rounded];
EOF

    sed -e 's/"/\\"/g' -e 's/commit \([^ ]*\) summary \(.*\)$/"\1" [id="id_\1", tooltip="\2"];/' "$git_graphviz"/commits-with-summaries.txt
    sed -e 's/commit \([^ ]*\) parents \(.*\)$/"\1" -> "\2";/' "$git_graphviz"/parent-1-to-commit.txt
    sed -e 's/commit \([^ ]*\) parents \(.*\)$/"\1" -> "\2" [taillabel="2"];/' "$git_graphviz"/parent-2-to-commit.txt

    if [[ true = ${decorate-false} ]]
    then

      cat <<EOF
    node [shape=plaintext];
EOF

      sed -e 's/name \([^ ]*\) references \(.*\)$/"tag:\1" -> "\2";/' "$git_graphviz"/lightweight-tag-to-commit.txt
      sed -e 's/name \([^ ]*\) references \(.*\)$/"\1" -> "\2";/' "$git_graphviz"/reference-to-commit.txt


      cat <<EOF
    node [shape=box, style=solid];
EOF

      sed -e 's/tag \([^ ]*\) name \([^ ]*\) references \(.*\)$/"\1" [label="\2"];"\1" -> "\3";/' "$git_graphviz"/tag-to-commit.txt

      sed -e 's/name \(.*\)$/"HEAD" [shape=plain];"HEAD" -> "\1";/' "$git_graphviz"/head-to-reference.txt

    fi
    
    cat <<EOF
}
EOF
} > "$git_graphviz"/graph.dot

dot -Tsvg -o"$git_graphviz"/graph.svg -Tcmapx -o"$git_graphviz"/graph.map "$git_graphviz"/graph.dot
base64 --wrap=0 "$git_graphviz"/graph.svg > "$git_graphviz"/graph.svg.base64

{
    cat <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <style type="text/css" media="all">
html {
  margin: 0;
  padding: 0;
}          
    </style>
    <title>Graphviz graph</title>
  </head>
  <body>
    <img src="data:image/svg+xml;base64,$(cat "$git_graphviz"/graph.svg.base64)" usemap="#git_graph"/>
EOF

    cat "$git_graphviz"/graph.map

    cat <<EOF
  </body>
</html>

EOF
} > "$git_graphviz"/graph.html

if [[ -n ${open+is-set} ]]
then
  OPEN_BIN=$(type -p open) || fail "program \"open\" not found"
  "$OPEN_BIN" "$git_graphviz"/graph.html
  read -t 3 -p 'press RETURN to exit, or wait'
else cat "$git_graphviz"/graph.html
fi
